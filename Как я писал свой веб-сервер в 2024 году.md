# Как я писал свой веб-сервер в 2024 году

В 2024 году я решил написать свой веб-сервер с нуля, чтобы лучше понять, как устроены современные веб-приложения и какие подходы используются в разработке. Это был интересный опыт, который помог мне глубже разобраться в протоколах, архитектуре сетевых приложений и современных технологиях.

## Мотивация

С каждым годом веб-разработка становится все более абстрактной. Мы используем фреймворки, библиотеки и готовые решения, часто не задумываясь о том, как все это работает под капотом. Решил вернуться к истокам и написать простой, но функциональный веб-сервер, который мог бы обрабатывать HTTP-запросы, отдавать статические файлы и поддерживать базовые возможности.

## Выбор языка программирования

Для реализации своего веб-сервера я выбрал язык Rust. Он предоставляет системный уровень производительности, безопасность памяти без сборщика мусора и отличную поддержку асинхронного программирования. В 2024 году Rust стал одним из самых популярных языков для системного программирования, и я хотел использовать его возможности на практике.

Для работы с сетью я использовал библиотеку Tokio, которая предоставляет асинхронный runtime и мощные примитивы для работы с сетевыми соединениями. Это позволило мне эффективно обрабатывать множество соединений одновременно без блокировки выполнения.

## Архитектура сервера

Я начал с простого однопоточного сервера, который слушал определенный порт и обрабатывал входящие соединения. Затем я перешел к асинхронной реализации, где каждое соединение обрабатывалось в отдельной задаче (task).

Сервер состоял из нескольких ключевых компонентов:
- Слушатель порта (TCP listener)
- Парсер HTTP-запросов
- Роутер для обработки разных URL
- Обработчик статических файлов
- Ответчик HTTP-запросов

## Реализация HTTP-парсера

Одной из самых интересных задач стала реализация HTTP-парсера. Я начал с поддержки только метода GET, так как это был мой первый опыт. Парсер анализировал заголовки запроса, извлекал путь к ресурсу и передавал управление соответствующему обработчику.

HTTP-запрос имеет следующую структуру:
- Стартовая строка (например, "GET /index.html HTTP/1.1")
- Заголовки (например, "Host: localhost:8080")
- Пустая строка, разделяющая заголовки и тело
- Тело запроса (для GET-запросов обычно отсутствует)

Я реализовал парсер, который разбирает эти компоненты и создает структуру данных, удобную для дальнейшей обработки.

## Обработка статических файлов

Следующим шагом стало создание обработчика статических файлов. Сервер должен был отдавать HTML, CSS, JavaScript и другие файлы из определенной директории. Я реализовал безопасный доступ к файловой системе, проверяя, что запрашиваемый путь находится внутри разрешенной директории, чтобы предотвратить path traversal атаки.

Для каждого запрашиваемого файла сервер проверял его существование, определял MIME-тип на основе расширения и отправлял соответствующие HTTP-заголовки.

## Асинхронная обработка

С переходом на асинхронную обработку я смог значительно увеличить производительность сервера. Используя Tokio, я создавал новую задачу для каждого входящего соединения, что позволяло обрабатывать сотни и даже тысячи соединений одновременно без значительного потребления ресурсов.

## Тестирование и отладка

Тестирование веб-сервера потребовало создания различных сценариев: нормальные запросы, некорректные запросы, запросы с неправильными заголовками, попытки доступа к несуществующим файлам. Я написал модульные тесты для парсера и интеграционные тесты для всего сервера.

Для тестирования я использовал библиотеку reqwest для отправки HTTP-запросов и проверки ответов сервера. Это помогло выявить и исправить множество мелких ошибок и улучшить стабильность работы.

## Безопасность

Безопасность была важным аспектом при разработке сервера. Я реализовал проверки на path traversal, ограничил размер заголовков и тела запроса, добавил защиту от DoS-атак через ограничение количества одновременных соединений.

Также я уделил внимание защите от XSS и других атак, хотя для простого статического сервера риски были минимальны.

## Производительность

Для улучшения производительности я использовал кеширование файлов в памяти, эффективные методы чтения из файловой системы и оптимизировал аллокации памяти. В 2024 году производительность остается критически важной, особенно для серверных приложений.

## Современные подходы

В 2024 году я также интегрировал поддержку HTTP/1.1 и начал работу над поддержкой HTTP/2. Современные веб-серверы должны поддерживать современные протоколы и стандарты, чтобы быть конкурентоспособными.

Я использовал современные инструменты разработки: форматтер rustfmt, линтер clippy, а также систему сборки Cargo. Это помогло поддерживать код в чистоте и находить потенциальные проблемы на ранних этапах.

## Заключение

Написание собственного веб-сервера в 2024 году стало для меня ценным опытом. Я глубже понял, как работают сетевые протоколы, как устроены веб-серверы и какие проблемы приходится решать при их разработке. Хотя мой сервер пока простой и не предназначен для продакшена, он стал отличной учебной базой для понимания веб-технологий.

Этот проект помог мне укрепить знания в области системного программирования, асинхронного программирования и сетевых технологий. Я планирую продолжать развивать этот проект, добавляя новые функции и улучшая производительность.